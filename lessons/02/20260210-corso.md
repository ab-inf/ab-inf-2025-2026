---
marp: true
theme: custom
transition: pivot
paginate: true

---

![bg right ""](img/0200.png)

<!-- footer: "" -->
<!-- paginate: False -->

# Abilità Informatiche (2025/2026)

## 02. Pensiero Computazionale

➡️ Mail: [sebastian.barzaghi2@unibo.it](mailto:sebastian.barzaghi2@unibo.it)
➡️ ORCID: [0000-0002-0799-1527](https://orcid.org/0000-0002-0799-1527)
➡️ Sito: [sebastian.barzaghi2](https://www.unibo.it/sitoweb/sebastian.barzaghi2/)

---

![bg "Marlyn Wescoff (standing) and Ruth Lichterman reprogram the ENIAC in 1946. https://www.messynessychic.com/2021/11/02/human-computer-the-forgotten-womens-profession/"](img/0201.png)

<!-- footer: "" -->
<!-- paginate: False -->


### Cos'è un computer?

---

![bg right "https://www.bbc.co.uk/bitesize/guides/zp92mp3/revision/1"](img/0202.png)

<!-- footer: Copeland, B. Jack, "The Modern History of Computing", The Stanford Encyclopedia of Philosophy (Winter 2020 Edition), Edward N. Zalta (ed.), URL: <a href="https://plato.stanford.edu/archives/win2020/entries/computing-history/">https://plato.stanford.edu/archives/win2020/entries/computing-history/</a> -->
<!-- paginate: True -->

### The kilo-girls

For hundreds of years, the term “computer” was a job title for a human before machines took over the job, and in the late 19th century, computers weren’t just human, they were mostly women. An English Countess and Victorian mathematician, Ada Lovelace, is regarded as the first computer programmer and by World War II, American industrialists were measuring the power of early computer devices in “kilo-girl” hours, not in megahertz or teraflops. It was Grace Hopper who developed the first compiler, Hollywood actress Hedy Lamarr invented the basis for modern Wi-Fi, and African-American female mathematicians like Katharine Johnson were the hidden force behind sending the first man to the moon

Prima degli anni ‘40: il _computer_ è una persona che effettua calcoli numerici a mano (es. posizioni dei pianeti, conversioni al sistema metrico).

---

![bg right contain "https://www.computerhistory.org/timeline/1982/"](img/0203.png)

<!-- footer: Copeland, B. Jack, "The Modern History of Computing", The Stanford Encyclopedia of Philosophy (Winter 2020 Edition), Edward N. Zalta (ed.), URL: <a href="https://plato.stanford.edu/archives/win2020/entries/computing-history/">https://plato.stanford.edu/archives/win2020/entries/computing-history/</a> -->

### Machine of the year

TIME magazine alters its annual tradition of naming a "Man of the Year," choosing instead to name the personal computer its "Machine of the Year." In introducing the theme, TIME publisher John A. Meyers wrote, "Several human candidates might have represented 1982, but none symbolized the past year more richly, or will be viewed by history as more significant, than a machine: the computer." His magazine, he explained, has chronicled the change in public opinion with regard to computers. A senior writer contributed: "computers were once regarded as distant, ominous abstractions, like Big Brother. In 1982, they truly became personalized, brought down to scale, so that people could hold, prod and play with them." At TIME, the main writer on the project completed his work on a typewriter, but Meyers noted that the magazine's newsroom would upgrade to word processors within a year.

Dopo gli anni '40: sistema elettronico (programmabile o non programmabile) di elaborazione delle informazioni.

---

![bg right "href="https://www.computerhistory.org/timeline/1986/"](img/0204.png)

<!-- footer: Copeland, B. Jack, "The Modern History of Computing", The Stanford Encyclopedia of Philosophy (Winter 2020 Edition), Edward N. Zalta (ed.), URL: <a href="https://plato.stanford.edu/archives/win2020/entries/computing-history/">https://plato.stanford.edu/archives/win2020/entries/computing-history/</a> -->

### Una definizione generale

Un agente che, se istruito correttamente, esegue calcoli a partire da qualche informazione iniziale (detta input) per produrre una risposta (detta output).

---

![bg right "https://www.britannica.com/facts/computer#/media/1/130429/94239"](img/0205.png)

<!-- footer: Hemmendinger, D. , Pottenger, . William Morton , Freiberger, . Paul A. and Swaine, . Michael R. (2023, December 28). computer. Encyclopedia Britannica. <a href="https://www.britannica.com/technology/computer">https://www.britannica.com/technology/computer</a>. -->

### Componente _hardware_

L'insieme delle componenti fisiche (alimentatori, elementi circuitali fissi, unità di memoria, ecc.), di un computer.

Piccoli chip di silicio che contengono innumerevoli transistor che funzionano come interruttori elettrici:
* Central Processing Unit (CPU): componente che coordina tutte le operazioni da eseguire;
* Random Access Memory (RAM): memoria volatile per registrare temporaneamente i dati;
* Read-Only Memory (ROM): memoria di sola lettura che contiene informazioni fisse e immodificabili;
* Memoria di massa (hard disk): memoria dove vengono conservati i dati in modo permanente;
* Scheda madre: connettore di tutti gli altri componenti interni.

Periferiche (Input/Output): tastiera, monitor, mouse...

---

<!-- footer: Hemmendinger, D. , Pottenger, . William Morton , Freiberger, . Paul A. and Swaine, . Michael R. (2023, December 28). computer. Encyclopedia Britannica. <a href="https://www.britannica.com/technology/computer">https://www.britannica.com/technology/computer</a>
-->

![bg right "https://www.britannica.com/technology/computer/images-videos#/media/1/130429/19612"](img/0206.png)

### Componente _software_

L’insieme delle componenti digitali (es. programmi, procedure, applicativi) assiociate alle operazioni effettuate da un computer.

Software di sistema: controlla il funzionamento interno del computer (es. sistema operativo) e gestisce anche dispositivi esterni

Software applicativo: fa eseguire ai computer i comandi dell'utente e include programmi che elaborano dati.

---

![bg "https://unsplash.com/photos/woman-in-black-coat-standing-in-front-of-mirror-WGeO6dW5GZM?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash"](img/0207.png)

<!-- footer: "" -->

---

![bg right "https://unsplash.com/photos/woman-in-black-coat-standing-in-front-of-mirror-WGeO6dW5GZM?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash"](img/0207.png)

<!-- footer: "" -->

### I computer servono a risolvere problemi

Tuttavia, prima che un problema possa essere affrontato, è necessario comprendere il problema stesso e i modi in cui potrebbe essere risolto.

Il pensiero computazionale ci permette di prendere un problema complesso, capire di che si tratta e sviluppare possibili soluzioni. 

Possiamo poi presentare queste soluzioni in un modo che un computer, un essere umano, o entrambi, possano comprendere.

---

![bg right "https://www.britannica.com/facts/computer#/media/1/130429/108250"](img/0208.png)

<!-- footer: Lodi, M., & Martini, S. (2021). Computational thinking, between Papert and Wing. Science & education, 30(4), 883-908. <a href="https://doi.org/10.1007/s11191-021-00202-5">https://doi.org/10.1007/s11191-021-00202-5</a> -->

### Mindstorms (Papert, 1980)

Impariamo costruendo iterativamente conoscenza.

Le _rappresentazioni potenti_ consentono un apprendimento efficace.

Il computer come _meta-strumento_ per “rendere l’astratto concreto” tramite un apprendimento per tentativi, sbagli, e correzioni.

Il pensiero computazionale come strumento di apprendimento basato sulla costruzione socialmente ed emotivamente partecipata di un artefatto.

---

![bg right ""](img/0109.png)

<!-- footer: Lodi, M., & Martini, S. (2021). Computational thinking, between Papert and Wing. Science & education, 30(4), 883-908. <a href="https://doi.org/10.1007/s11191-021-00202-5">https://doi.org/10.1007/s11191-021-00202-5</a> -->

### Computational Thinking (Wing, 2006)

Esiste una disponibilità enorme di strumenti digitali, soprattutto sul World Wide Web.

La maggior parte delle discipline diventano “computazionali”.

Diventa quindi necessario assumere un approccio basato sulla computazione che aiuta a risolvere problemi e progettare soluzioni.

---

![bg contain "https://www.bbc.co.uk/bitesize/guides/zp92mp3/revision/1"](img/0110.png)

<!-- footer: "" -->
<!-- paginate: False -->

---

![bg right contain "https://www.bbc.co.uk/bitesize/guides/zp92mp3/revision/1"](https://bam.files.bbci.co.uk/bam/live/content/zg6bgk7/large)

<!-- footer: "" -->
<!-- paginate: True -->

### I principi della computazione

Decomposizione: dividere un problema in parti più piccole e gestibili

Riconoscimento di pattern: cercare somiglianze e tendenze nei componenti del problema

Astrazione: focalizzarsi solo sulle informazioni rilevanti, rimuovendo dettagli non necessari

Algoritmi: sviluppare una soluzione sequenziale al problema

---

![bg right contain ""](img/0111.png)

<!-- footer: Lodi, M., & Martini, S. (2021). Computational thinking, between Papert and Wing. Science & education, 30(4), 883-908. a href="https://doi.org/10.1007/s11191-021-00202-5">https://doi.org/10.1007/s11191-021-00202-5</a> -->

### Un approccio di risoluzione dei problemi basato sui principi della computazione

Il pensiero computazionale consiste nel prendere un problema complesso e suddividerlo in una serie di problemi più piccoli e gestibili (decomposizione). 

Ognuno di questi problemi più piccoli può essere esaminato singolarmente, considerando come problemi simili sono stati risolti in passato (riconoscimento di pattern) e concentrandosi solo sui dettagli importanti, ignorando le informazioni irrilevanti (astrazione). 

Successivamente, si possono progettare passi o regole semplici per risolvere ciascuno di questi problemi più piccoli (algoritmi).

Infine, questi semplici passi o regole vengono utilizzati per programmare un computer che aiuti a risolvere il problema complesso nel miglior modo possibile.

---

https://www.bbc.co.uk/bitesize/guides/zp92mp3/revision/2

### Esempio: sviluppo di un videogioco

Immaginiamo di voler creare un videogioco. 

Domanda: _come possiamo affrontare questo problema usando il pensiero computazionale?_

---

![bg contain "https://www.bbc.co.uk/bitesize/guides/zqqfyrd/revision/1"](img/0112.png)

<!-- footer: "" -->

---

![bg right "https://www.bbc.co.uk/bitesize/guides/zqqfyrd/revision/1"](img/0113.png)

<!-- footer: "" -->

### Decomposizione

Affrontare più fasi diverse contemporaneamente è molto più complicato che suddividere il problema in parti più piccole e risolverle una alla volta.

La decomposizione è la suddivisione di  un problema complesso o di un sistema in parti più piccole, che sono più gestibili e facili da comprendere.

---

Decomponiamo il problema in una serie di problemi più piccoli:

* che tipo di videogioco vogliamo creare;
* chi sarà il pubblico target del videogioco;
* come sono gli asset grafici;
* quali strumenti utilizziamo per svilupparlo;
* com'è l'esperienza dell'utente;
* come lo testiamo;
* dove lo distribuiamo e/o vendiamo.

---

![bg "https://www.bbc.co.uk/bitesize/guides/zqqfyrd/revision/1"](img/0114.png)

<!-- footer: "" -->

---

![bg right "https://www.bbc.co.uk/bitesize/guides/zqqfyrd/revision/1"](img/0114.png)

<!-- footer: "" -->

### Riconoscimento di pattern

Quando decomponiamo un problema complesso, spesso troviamo pattern tra i sotto-problemi. I pattern sono somiglianze o caratteristiche condivise che si ripetono.

Trovare somiglianze tra i problemi decomposti ci permette di risolverli in modo più efficiente.

Trovare pattern è fondamentale perché semplifica la risoluzione dei problemi, potendo applicare la stessa soluzione ovunque si presenti lo stesso pattern.

---

![bg "https://www.bbc.co.uk/bitesize/guides/zxxbgk7/revision/3"](img/0114.png)

<!-- footer: "" -->

### Pattern tra problemi diversi

Preparare una torta implica risolvere vari problemi, come scegliere gli ingredienti e il tempo di cottura. Una volta che conosciamo il processo per una torta, possiamo applicarlo anche ad altre, poiché esistono schemi comuni, come le quantità precise di ingredienti e i tempi di cottura.

Identificando questi pattern, possiamo trovare soluzioni comuni per problemi simili.

Durante la preparazione di una torta, possiamo trovare pattern anche nei problemi più piccoli. 

Ad esempio, sapendo che "ogni torta avrà bisogno di una quantità precisa di ingredienti specifici", ogni ingrediente deve:

* essere identificato con un nome;
* avere una misura specifica.

Una volta che sappiamo come identificare ogni ingrediente e la sua quantità, possiamo applicare questo pattern a tutti gli ingredienti. 

Di nuovo, ciò che cambia sono i dettagli specifici.

---

...

---

![bg "https://www.bbc.co.uk/bitesize/guides/zttrcdm/revision/1"](img/0114.png)

<!-- footer: "" -->

---

![bg right contain "https://www.bbc.co.uk/bitesize/guides/zttrcdm/revision/1"](img/0115.png)

<!-- footer: "" -->

### Astrazione

Quando decomponiamo i problemi, cerchiamo pattern tra e all'interno dei problemi più piccoli che compongono il problema complesso.

L'astrazione è il processo di eliminare le caratteristiche dei pattern che non ci servono, per concentrarci su quelle che ci sono utili e creare così una rappresentazione di ciò che stiamo cercando di risolvere.

L'astrazione ci permette di concentrarci solo sulle caratteristiche essenziali, creando così un'idea di base di cosa sia un gatto, che ci aiuta a disegnarlo.

---

<!-- footer: "" -->

![bg right "https://www.bbc.co.uk/bitesize/guides/zttrcdm/revision/1"](img/0116.png)

### Creare un modello

Un modello è un'idea generale, un'astrazione. Ad esempio, un modello di gatto rappresenta tutti i gatti, un modello di torta rappresenta tutte le torte, e così via.

I modelli ci permettono di comprendere gli schemi comuni tra gli oggetti o situazioni e di applicarli per risolvere il problema.

Una volta creato un modello, possiamo progettare un algoritmo per risolverlo.

---

...

---

![bg "https://www.bbc.co.uk/bitesize/guides/zqqfyrd/revision/2"](img/0114.png)

<!-- footer: "" -->

---

![bg "https://www.bbc.co.uk/bitesize/guides/zqqfyrd/revision/2"](img/0114.png)

<!-- footer: "" -->

### Algoritmo

Una sequenza finita di procedure precise per produrre un risultato (output) a partire da uno stato iniziale (input).

Gli algoritmi sono spesso usati come base per sviluppare software. Possono essere espressi come diagrammi di flusso oppure come pseudocodice.

* Sequenziali;
* Finiti;
* Generali;
* Non ambigui;
* Corretti;
* Efficienti.

Gli algoritmi possono essere usati per descrivere praticamente qualsiasi tipo di processo.

---

### Garbage in, garbage out

Se vogliamo dire a un computer di fare qualcosa, dobbiamo scrivere un programma che indichi, passo dopo passo, esattamente cosa vogliamo che faccia e come vogliamo che lo faccia. 

Questo programma necessita di pianificazione, e per farlo utilizziamo un algoritmo.

I computer sono tanto bravi quanto gli algoritmi che vengono loro forniti: un algoritmo scadente porta ad un risultato scadente.

---

### Un algoritmo deve essere chiaro

Possiamo suddividere il problema in parti più piccole e poi pianificare come queste si combinano di nuovo in un ordine appropriato per risolvere il problema.

Questo ordine può essere rappresentato come un algoritmo. 

Deve avere un punto di partenza, un punto di arrivo e un insieme di istruzioni chiare nel mezzo.

---

### Come rappresentare un algoritmo: Pseudocodice

La maggior parte dei programmi viene sviluppata utilizzando linguaggi di programmazione. 

Questi linguaggi hanno una sintassi specifica che deve essere utilizzata affinché il programma funzioni correttamente. 

Lo pseudocodice è un modo semplice di descrivere un insieme di istruzioni che non deve seguire una sintassi specifica.

---

### Scrivere in pseudocodice è simile a scrivere in un linguaggio di programmazione

```
OUTPUT 'What is your name?'
INPUT user inputs their name
STORE the user's input in the name variable
OUTPUT 'Hello' + name
OUTPUT 'How old are you?'
INPUT user inputs their age
STORE the user's input in the age variable
IF age >= 70 THEN
OUTPUT 'You are aged to perfection!'
ELSE
OUTPUT 'You are a spring chicken!'
```

Un programma che chiede all'utente il nome e l'età e che fa un commento sulla base di questi.

---

![bg right "https://www.lospaziodirosanna.it/testo-e-testi/algoritmi-diagrammi-di-flusso-esempi-e-attivita/"](img/0114.png)

<!-- footer: "" -->

### Come rappresentare un algoritmo: Diagramma di flusso

La rappresentazione grafica di un algoritmo.

Non ci sono molte regole precise riguardo al livello di dettaglio necessario in un diagramma di flusso. A volte vengono suddivisi in molti passaggi per fornire più dettagli, altre volte vengono semplificati per essere più comprensibili.

---

![bg right "https://www.bbc.co.uk/bitesize/guides/zpp49j6/revision/3"](img/0114.png)

<!-- footer: "" -->

---

![bg right "https://www.bbc.co.uk/bitesize/guides/zpp49j6/revision/3"](img/0114.png)

<!-- footer: "" -->

---

quali oggetti dobbiamo raccogliere
come possiamo raccoglierli;
quanto tempo abbiamo per raccoglierli;
dove si trova l'uscita;
qual è il miglior percorso per raggiungerla nel minor tempo possibile;
che tipo di nemici ci sono;
quali sono i loro punti deboli.

---

![bg right "Photo by <a href="https://unsplash.com/@sandradempseydesigns?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Sandra Dempsey</a> on <a href="https://unsplash.com/photos/white-and-green-floral-ceiling-aMcEAPPbW0w?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a>"](img/0100.png)

<!-- footer: "" -->

# Abilità Informatiche (2025/2026)

## 02. Pensiero Computazionale

➡️ Mail: [sebastian.barzaghi2@unibo.it](mailto:sebastian.barzaghi2@unibo.it)
➡️ ORCID: [0000-0002-0799-1527](https://orcid.org/0000-0002-0799-1527)
➡️ Sito: [sebastian.barzaghi2](https://www.unibo.it/sitoweb/sebastian.barzaghi2/)

