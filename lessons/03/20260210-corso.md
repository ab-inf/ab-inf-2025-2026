---
marp: true
theme: custom
transition: pivot
paginate: true

---

![bg right "https://unsplash.com/photos/YBxyb8hyNmE"](img/0200.png)

<!-- footer: "" -->
<!-- paginate: False -->

# Abilità Informatiche (2025/2026)

## 03. Rappresentare Informazioni

➡️ Mail: [sebastian.barzaghi2@unibo.it](mailto:sebastian.barzaghi2@unibo.it)
➡️ ORCID: [0000-0002-0799-1527](https://orcid.org/0000-0002-0799-1527)
➡️ Sito: [sebastian.barzaghi2](https://www.unibo.it/sitoweb/sebastian.barzaghi2/)

---

![bg ""](img/0201.png)

<!-- footer:  -->
<!-- paginate: False -->


### 

---

![bg right ""](img/0202.png)

<!-- footer:  -->
<!-- paginate: True -->

### 

---

![bg right contain ""](img/0203.png)

<!-- footer:  -->

### 

---

![bg right ""](img/0204.png)

<!-- footer:  -->

### 

---

![bg right "https://unsplash.com/photos/man-in-black-helmet-riding-brown-horse-during-daytime-9h_bJdGqzCk?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash"](img/0205.png)

<!-- footer: Formal and Natural Languages. In How To Think Like A Computer Scientist: Interactive Edition. <a href="https://runestone.academy/ns/books/published/thinkcspy/GeneralIntro/FormalandNaturalLanguages.html">https://runestone.academy/ns/books/published/thinkcspy/GeneralIntro/FormalandNaturalLanguages.html</a> -->

### Un linguaggio naturale è quello parlato da noi

Linguaggio caratterizzato da ricchezza espressiva, ambiguità e ridondanza, per cui un qualsiasi costrutto formulato è potenzialmente polisemico.

Esempio: "Sposto il cavallo".

---

![bg right "https://unsplash.com/photos/woman-in-black-long-sleeve-shirt-GzDrm7SYQ0g?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash"](img/0206.png)

<!-- footer: Formal and Natural Languages. In How To Think Like A Computer Scientist: Interactive Edition. <a href="https://runestone.academy/ns/books/published/thinkcspy/GeneralIntro/FormalandNaturalLanguages.html">https://runestone.academy/ns/books/published/thinkcspy/GeneralIntro/FormalandNaturalLanguages.html</a>
-->

### Un linguaggio formale è quello usato per ridurre al minimo l'incertezza

Linguaggio per formulare costrutti dotati di significato in modo preciso e non ambiguo.

Per comunicare con un computer, l'ambiguità del linguaggio naturale è un problema (servono altre informazioni relative al contesto e alla pragmatica che un computer, di base, non recepisce), quindi vengono usati linguaggi formali.

---

![bg ""](img/0207.png)

<!-- footer: "" -->

---

![bg right ""](img/0207.png)

<!-- footer: "" -->

### Un linguaggio formale è costituito da tre elementi

* **Alfabeto**: insieme finito di simboli;
  * Esempio: `{a, b, c}` (un alfabeto costituito da tre simboli: `a`, `b` e `c`);
* **Grammatica**: insieme di regole sintattiche che specificano combinazioni valide di simboli;
  * Esempio: `G → a ∣ b ∣ c` (`G` è una grammatica che stabilisce che possiamo solo usare `a`, `b` o `c` separatamente);
* **Semantica**: insieme di significati attribuiti ai simboli e alle loro combinazioni;
  * Esempio: `a: "rosso" ; b: "blu" ; c: "verde"` (ad ogni simbolo ed eventuali combinazioni viene associato un significato).

---

![bg right ""](img/0208.png)

<!-- footer:  -->

---

![bg right ""](img/0209.png)

<!-- footer:  -->

### La codifica

Una codifica è il processo di trasformazione di un'informazione da un alfabeto ad un altro

Tecnica con la quale un dato viene rappresentato mediante un definito insieme di simboli.

Con tali simboli è possibile formare sequenze che possono essere messe in relazione biunivoca con gli elementi costituenti l'informazione.

Esempi:
* Numero di matricola
* Braille
* Codice fiscale
* Morse
* ...

---

![bg contain ""](img/0210.png)

<!-- footer: "" -->
<!-- paginate: False -->

---

![bg right contain ""](img/0210.png)

<!-- footer: Rappresentazione posizionale degli interi. <a href="http://www-dft.ts.infn.it/~pastore/DIDA/MNF/posizionale.html">http://www-dft.ts.infn.it/~pastore/DIDA/MNF/posizionale.html</a> -->
<!-- paginate: True -->

### Partiamo dalla notazione decimale posizionale

La codifica più comunemente adottata oggi per la rappresentazione dei numeri interi.

Il termine **decimale** indica il numero di simboli utilizzati (**cifre**): `{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}`.

Il termine **posizionale** indica che il significato dei simboli cambia in base alla loro posizione. Il numero rappresentato da ogni simbolo è moltiplicato per una potenza di 10 (il numero di simboli che cotituiscono l'alfabeto, la **base**).

Con `n` cifre è possibile rappresentare 10<sup>n</sup> numeri naturali: da 0 a 10<sup>n</sup>-1.

Es. con 4 cifre possiamo rappresentare 10<sup>4</sup> numeri (da 0 a 9999).

---

![bg right contain ""](img/0210.png)

<!-- footer: Rappresentazione posizionale degli interi. <a href="http://www-dft.ts.infn.it/~pastore/DIDA/MNF/posizionale.html">http://www-dft.ts.infn.it/~pastore/DIDA/MNF/posizionale.html</a> -->

### Esempio: il numero 2465

Il significato di ogni simbolo dipende dalla posizione di questo all'interno della sequenza di simboli creata in base alla loro combinazione. 

<code>2 X 10<sup>3</sup> + 4 X 10<sup>2</sup> + 6 X 10<sup>1</sup> + 5 X 10<sup>0</sup></code>

Che equivale a 2 _migliaia_ + 4 _centinaia_ + 6 _decine_ + 5 _unità_.

---

![bg right contain ""](img/0211.png)

<!-- footer: "" -->
<!-- paginate: True -->

### Esistono codifiche non posizionali?

Il sistema di numerazione romano!

Si tratta di un **sistema additivo** basato su:

* Un alfabeto di simboli letterari a ciascuno dei quali viene assegnato un valore numerico;
* Un numero è rappresentato da una sequenza di tali simboli;
* Il valore di un numero è dato dalla somma dei valori corrispondenti ai simboli ottenuti, se in ordine decrescente; altrimenti, li si sottrae.

Esempi:
* `VIII = 5 + 1 + 1 + 1 = 8`;
* `IV = 5 - 1 = 4`.

---

![bg contain ""](img/0212.png)

<!-- footer: "" -->

---

![bg right contain "https://unsplash.com/photos/close-up-photography-of-green-motherboard--9jmFkN-_U4?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash"](img/0212.png)

<!-- footer: "" -->

### L'informazione va codificata per il computer

Il computer memorizza ed elabora vari tipi di informazioni (numeri, testi, immagini, suoni, ecc.).

Occorre rappresentare tale informazione in un formato facilmente manipolabile dal computer.

---

![bg right contain "https://unsplash.com/photos/a-light-switch-cover-on-a-white-wall-Ual1Obieofc?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash"](img/0213.png)

<!-- footer: "" -->

### Di fatto, un computer è una grande collezione di dispositivi _bistabili_

"Bistabile" indica qualcosa che può assumere nel tempo solo due stati stabili (es. interruttore). Nel caso del computer, si tratta della presenza / assenza di corrente elettrica.

Per ogni tipo di informazione (numerica, testuale, grafica, sonora, ecc.) che vogliamo trattare con un computer, dobbiamo individuare una codifica che si avvalga esclusivamente di questa caratteristica.

---

![bg right ""](img/0214.png)

<!-- footer: History of the Binary System. In Cut The Knot. <a href="https://www.cut-the-knot.org/do_you_know/BinaryHistory.shtml">https://www.cut-the-knot.org/do_you_know/BinaryHistory.shtml</a>. -->

### Consideriamo un alfabeto binario

Alfabeto: `{0, 1}`.

**Bit**: cifra binaria, ovvero uno dei due simboli del sistema numerico binario, classicamente chiamati _zero_ (0) e _uno_ (1).

Allo _zero_ sono spesso associate le idee di "chiuso", "spento", "assente", "falso".

All'_uno_ sono spesso associate le idee di "aperto", "acceso", "presente", "vero".

---

![bg right contain ""](img/0214.png)

<!-- footer: "" -->

### ...

Con 1 bit rappresentiamo poco: solo 2 diverse informazioni:

* 0 → No / Falso / Off;
* 1 → Si / Vero / On.

Ma se usassimo più bit? Proviamo a rappresentare le stagioni con una codifica binaria. Le stagioni sono 4, quindi ci servono 2 bit (2<sup>2</sup> sequenze possibili).

* 00 → Primavera;
* 10 → Estate;
* 01 → Autunno; 
* 11 → Inverno.

---

![bg right contain ""](img/0215.png)

<!-- footer: "" -->

### La binarietà è conveniente

2 bit : 4 (2<sup>2</sup>) sequenze possibili: 00, 01, 10, 11.

3 bit: 8 (2<sup>3</sup>) sequenze possibili: 000, 001, 010, 100, 011, 101, 110, 111.

Con `n bit` possiamo rappresentare 2<sup>n</sup> sequenze: da 0 a 2<sup>n</sup>-1.

8 bit costituiscono un **byte**.

---

![bg right contain ""](img/0216.png)

<!-- footer: "" -->

### Codifica numerica da base 2 a base 10

Moltiplicare ogni bit per il suo peso (attenzione a partire da 2<sup>n</sup>-1!) e sommare le potenze.

10100  

1 X 2<sup>4</sup> + 0 X 2<sup>3</sup> + 1 X 2<sup>2</sup> + 0 X 2<sup>1</sup> + 0 X 2<sup>0</sup>  
= 1 X 16 + 0 X 8 + 1 X 4 + 0 X 2 + 0 X 1  
= 16 + 0 + 4 + 0 + 0  

= 20  

---

![bg right contain ""](img/0217.png)

<!-- footer: "" -->

### ### Codifica numerica da base 10 a base 2

Dividere il numero per 2 ripetutamente fino ad arrivare a zero e disporre i resti in ordine inverso.

12

12 / 2 → resto 0
= 6 / 2 → resto 0
= 3 / 2 → resto 1
= 1 / 2 → resto 1 

Prendiamo i resti dall'ultimo al primo:

= 1100

---

![bg right ""](img/0218.png)

<!-- footer: "" -->

### Quindi…

* Conosciamo la numerazione in base 2;
* Conosciamo la numerazione in base 10;
* Sappiamo passare da una base di numerazione all'altra (cioé convertire i numeri in bit).

Come digitalizziamo invece la lettera `a`?

---

![bg right contain ""](img/0218.png)

<!-- footer: "" -->

---

![bg right contain ""](img/0218.png)

<!-- footer: "" -->

### I caratteri corrispondono a codici binari

L'alfabeto anglosassone ha circa 120 caratteri (maiuscole + minuscole + numeri + interpunzione + ...)

Quanti bit ci servono per coprirli tutti?

Bastano 7 bit = 2<sup>7</sup> = 128 sequenze.

---

![bg right contain "https://www.bbc.co.uk/bitesize/guides/zttrcdm/revision/1"](img/0216.png)

<!-- footer: "" -->

### American Standard Code for Information Interchange (ASCII)

Codifica secondo la quale ogni carattere è rappresentato da una sequenza di 7 bit.

Esempi:

* `A` → `1000001`;
* `B` → `1000010`;
* `BABA` → `1000010 1000001 1000010 1000001`.

---

![bg contain "https://www.bbc.co.uk/bitesize/guides/zqqfyrd/revision/2"](img/0219.png)

<!-- footer: "" -->

### ASCII esteso

* Estensione di ASCII a 8 bit (2<sup>8</sup> = 256 simboli);
* Codifica quasi tutti i linguaggi occidentali;
* Include molti altri simboli utili.

Esempi:

* `CAT` → `01000011 01000001 01010100`;
* `cat` → `01100011 01100001 01110100`.

---

![bg right contain "https://computerscienceiseasy.com/an-introduction-to-ascii-and-unicode/"](img/0219.png)

<!-- footer: "" -->

---

![bg right contain "https://computerscienceiseasy.com/an-introduction-to-ascii-and-unicode/"](img/0219.png)

<!-- footer: "" -->

### L'altra metà del problema

La digitalizzazione - cioé codificare contenuto informativo in binario - è solo metà del problema.

Dobbiamo anche codificare le caratteristiche del contenuto, cioé contestualizzarlo ("specificare le unità di misura", nel caso della sonda spaziale).

---

![bg right contain "https://www.bbc.co.uk/bitesize/guides/zqqfyrd/revision/2"](img/0220.png)

<!-- footer: "" -->

### Garbage in, garbage out

Se vogliamo dire a un computer di fare qualcosa, dobbiamo scrivere un programma che indichi, passo dopo passo, esattamente cosa vogliamo che faccia e come vogliamo che lo faccia. 

I computer sono tanto bravi quanto gli algoritmi che vengono loro forniti: un algoritmo scadente porta ad un risultato scadente.

Un buon algoritmo deve avere un punto di partenza, un punto di arrivo e un insieme di istruzioni chiare nel mezzo.

---

![bg right contain "https://www.bbc.co.uk/bitesize/guides/zqqfyrd/revision/2"](img/0221.png)

<!-- footer: "" -->

### Come rappresentare un algoritmo: Pseudocodice

La maggior parte dei programmi viene sviluppata utilizzando linguaggi di programmazione. 

Questi linguaggi hanno una sintassi specifica che deve essere utilizzata affinché il programma funzioni correttamente. 

Lo pseudocodice è un modo semplice di descrivere un insieme di istruzioni che non segue la sintassi specifica di un linguaggio di programmazione, ma la riproduce, "imitando" alcune logiche della computazione.

---

![bg right contain "https://www.lospaziodirosanna.it/testo-e-testi/algoritmi-diagrammi-di-flusso-esempi-e-attivita/"](img/0222.png)

<!-- footer: "" -->

### Come rappresentare un algoritmo: Diagramma di flusso

Un diagramma di flusso non è altro che la rappresentazione grafica di un algoritmo.

Non ci sono molte regole precise riguardo al livello di dettaglio necessario in un diagramma di flusso. Si tratta piuttosto di convenzioni seguite dalla stragrande maggioranza delle persone.

A volte vengono suddivisi in molti passaggi per fornire più dettagli, altre volte vengono semplificati per essere più comprensibili.

---

![bg contain "https://www.bbc.co.uk/bitesize/guides/zpp49j6/revision/3"](img/0223.png)

<!-- footer: "" -->

---

![bg contain "https://www.bbc.co.uk/bitesize/guides/zpp49j6/revision/3"](img/0221.png)

![bg contain "https://www.bbc.co.uk/bitesize/guides/zpp49j6/revision/3"](img/0223.png)

<!-- footer: "" -->

---

![bg right "https://unsplash.com/photos/YBxyb8hyNmE">Unsplash</a>"](img/0200.png)

<!-- footer: "" -->

# Abilità Informatiche (2025/2026)

## 03. Rappresentare l'informazione

➡️ Mail: [sebastian.barzaghi2@unibo.it](mailto:sebastian.barzaghi2@unibo.it)
➡️ ORCID: [0000-0002-0799-1527](https://orcid.org/0000-0002-0799-1527)
➡️ Sito: [sebastian.barzaghi2](https://www.unibo.it/sitoweb/sebastian.barzaghi2/)

